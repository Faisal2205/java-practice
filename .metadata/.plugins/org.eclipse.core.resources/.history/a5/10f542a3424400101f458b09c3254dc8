package com.singleton;

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutput;
import java.io.ObjectOutputStream;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;

public class Main {
	

	public static void main(String[] args) {
		
//		Thread t1 = new Thread(() ->{
//             Samosa samosa1 = Samosa.getSamosa();	
//			System.out.println(samosa1.hashCode());
//			
//		});
//		Thread t2 = new Thread(()->{
//         Samosa samosa2 = Samosa.getSamosa();
//			System.out.println(samosa2.hashCode());
//		});
//		t1.start();
//		t2.start();
	
		
		
		
		
		
		// This is not a good way to create Singleton object. because if client does not need of object fir bhi its crating the object. 
		
//		Jalebi j1 = Jalebi.getJalebi();
//		Jalebi j2 = Jalebi.getJalebi();
//		
//		System.out.println(j1.hashCode());
//		System.out.println(j2.hashCode());

		
		//         1.   Breaking singleton by Reflecting API
		
		//         Sol: i) if object is there ==> throw exception from inside constructor
		
		//          ii) by using enum we save to reflection API
		
		//          2. Breaking Singleton by deserialization 
		
//		Samosa s1 = Samosa.getSamosa();
//		System.out.println(s1.hashCode());
//		
//		Constructor<Samosa> constructor = Samosa.class.getDeclaredConstructor();
//		constructor.setAccessible(true);
//		 Samosa s2 =constructor.newInstance();
//		 System.out.println(s2.hashCode());
		
		//             2---------
		Samosa samosa = Samosa.getSamosa()
		
		ObjectOutput oos = new ObjectOutputStream(new FileOutputStream("abc.obj"));
		oos.writeObject(samosa);
		
		System.out.println("Serialization Done..");
		System.out.println(samosa.hashCode());
		
		ObjectInputStream ois = new ObjectInputStream(new FileInputStream("abc.obj"));
		Samosa s2 = (Samosa)ois.readObject();
		System.out.println(s2.hashCode());
		
	}
}
